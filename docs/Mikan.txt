-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package Mikan
@version 0.0.3

module Mikan
mikan :: String -> IO ()

module Core.Type
data Token
A :: String -> Token
L :: [Token] -> Token
type UnIndexedTerm = Term String
type IndexedTerm = Term Int
data Term a
Succ :: (Term a) -> Term a
Pred :: (Term a) -> Term a
Zero :: Term a
IsZero :: (Term a) -> Term a
If :: (Term a) -> (Term a) -> (Term a) -> Term a
True :: Term a
False :: Term a
Var :: a -> Term a
Lambda :: String -> (Term a) -> Term a
type NameSpace = Map Int (Term Int)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Core.Type.Term a)
instance GHC.Classes.Eq Core.Type.Token
instance GHC.Show.Show Core.Type.Token
instance GHC.Show.Show a => GHC.Show.Show (Core.Type.Term a)

module Core.Parser

-- | 最小単位に分解された文字を
--   
--   <ol>
--   <li>木に変換する</li>
--   <li>名前から解放して、de brujin indexingする</li>
--   <li>名前空間を生成する</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; parser $ L [A "if", A "true", A "zero", A "false"]
--   (if true zero false)
--   </pre>
parser :: (MonadThrow m, MonadState NameSpace m) => Token -> m IndexedTerm

module Core.Lexer

-- | 文字列を最小単位に分解します
--   
--   <pre>
--   &gt;&gt;&gt; lexer "a b c"
--   L [A "a", A "b", A "c"]
--   </pre>
lexer :: MonadThrow m => String -> m Token

module Core.Evaluater

-- | 木構造に整理されたプログラムを評価する
evaluater :: (MonadThrow m, MonadIO m, MonadState NameSpace m) => IndexedTerm -> m ()

module Core.Core

-- | 文字列を最小単位に分解します
--   
--   <pre>
--   &gt;&gt;&gt; lexer "a b c"
--   L [A "a", A "b", A "c"]
--   </pre>
lexer :: MonadThrow m => String -> m Token

-- | 最小単位に分解された文字を
--   
--   <ol>
--   <li>木に変換する</li>
--   <li>名前から解放して、de brujin indexingする</li>
--   <li>名前空間を生成する</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; parser $ L [A "if", A "true", A "zero", A "false"]
--   (if true zero false)
--   </pre>
parser :: (MonadThrow m, MonadState NameSpace m) => Token -> m IndexedTerm

-- | 木構造に整理されたプログラムを評価する
evaluater :: (MonadThrow m, MonadIO m, MonadState NameSpace m) => IndexedTerm -> m ()
